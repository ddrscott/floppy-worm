<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Worm Flop Physics</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a2e;
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="info">
        <h3>Worm Flop Physics</h3>
        <p>Arrow Keys: Bend worm left/right<br>
        Spacebar: Compress (hold) / Release to jump<br>
        Mouse: Drag worm segments</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
    <script>
        // Matter.js modules
        const Engine = Matter.Engine,
              Render = Matter.Render,
              Runner = Matter.Runner,
              Bodies = Matter.Bodies,
              Body = Matter.Body,
              Composite = Matter.Composite,
              Composites = Matter.Composites,
              Constraint = Matter.Constraint,
              Mouse = Matter.Mouse,
              MouseConstraint = Matter.MouseConstraint,
              Events = Matter.Events,
              Vector = Matter.Vector,
              Common = Matter.Common;

        // Soft body creation function adapted from example
        function createSoftBody(xx, yy, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions) {
            particleOptions = Common.extend({}, particleOptions);  // Removed infinite inertia
            constraintOptions = Common.extend({ stiffness: 0.2, render: { type: 'line', anchors: false } }, constraintOptions);

            var softBody = Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function(x, y) {
                return Bodies.circle(x, y, particleRadius, particleOptions);
            });

            Composites.mesh(softBody, columns, rows, crossBrace, constraintOptions);

            softBody.label = 'Soft Body Worm';

            return softBody;
        }

        // Create engine
        const engine = Engine.create();
        const world = engine.world;
        engine.gravity.scale = 0.001;

        // Create renderer
        const render = Render.create({
            element: document.body,
            engine: engine,
            options: {
                width: window.innerWidth,
                height: window.innerHeight,
                wireframes: false,
                background: '#1a1a2e',
                showVelocity: false
            }
        });

        // Create runner
        const runner = Runner.create();

        // Physics parameters for dat.GUI
        const physicsParams = {
            // Movement
            movementForce: 0.003,
            upwardForce: 0.006,
            numSegmentsToMove: 2,
            torqueAmount: 0.01,
            
            // Tail physics
            tailDensity: 0.002,
            tailInertiaMultiplier: 10,
            tailFriction: 0.9,
            tailStaticFriction: 0.95,
            tailSegments: 3,
            
            // Head physics
            headDensity: 0.0005,
            
            // Body physics
            bodyDensity: 0.01,
            bodyFriction: 0.1,
            bodyStaticFriction: 0.5,
            bodyAirFriction: 0.02,  // Increased to reduce drift
            
            // Constraints
            constraintStiffness: 0.8,  // Increased from 0.3 for stiffer joints
            constraintDamping: 0.1,    // Slightly increased damping
            compressStiffness: 0.95,   // Slightly higher compress stiffness
            
            // Mass gradient
            massGradientMultiplier: 0.7
        };

        // Worm parameters
        const wormColumns = 1;  // Width of worm (3 segments wide)
        const wormRows = 13;     // Length of worm (7 segments long)
        const particleRadius = 10;
        const columnGap = 0;
        const rowGap = 0;
        const crossBrace = false;  // Add diagonal constraints for stability
        const startX = window.innerWidth / 2 - (wormColumns * particleRadius);
        const startY = window.innerHeight - 350;  // Start position higher from ground

        // Particle options for worm segments - default for body
        const particleOptions = {
            density: 0.001,  // Light body segments
            friction: 0.01,  // Reduced friction for easier sliding
            frictionStatic: 0.05,  // Reduced static friction
            frictionAir: physicsParams.bodyAirFriction,  // Use GUI value
            restitution: 0.05,  // Reduced bounce to prevent energy gain
            render: {
                fillStyle: '#95e1d3',
                strokeStyle: '#6bc5b8',
                lineWidth: 1,
                visible: true
            }
        };

        // Constraint options
        const baseStiffness = physicsParams.constraintStiffness;  // Use GUI value
        const compressStiffness = physicsParams.compressStiffness;
        const constraintOptions = {
            stiffness: baseStiffness,
            damping: physicsParams.constraintDamping,  // Use GUI value
            render: {
                visible: true,
                type: 'line',
                strokeStyle: '#556b8d',
                lineWidth: 1,
                anchors: false
            }
        };

        // Create soft body worm
        const worm = createSoftBody(startX, startY, wormColumns, wormRows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions);
        
        // Color the head and tail differently
        const wormBodies = worm.bodies;
        const numBodies = wormBodies.length;
        
        // Apply mass gradient - heavier at the tail
        for (let i = 0; i < numBodies; i++) {
            const segmentRow = Math.floor(i / wormColumns);
            const massMultiplier = 1 + (segmentRow * 0.5); // Gradually increase mass toward tail
            Body.setMass(wormBodies[i], wormBodies[i].mass * massMultiplier);
        }
        
        // Color the top row (head) red - lightweight
        for (let i = numBodies - wormColumns; i < numBodies; i++) {
            wormBodies[i].render.fillStyle = '#ff6b6b';
            wormBodies[i].render.strokeStyle = '#ff4444';
            Body.setDensity(wormBodies[i], 0.0005); // Very light head
        }
        
        // Color the bottom segments (tail) teal - extremely heavy
        for (let i = 0; i < physicsParams.tailSegments * wormColumns; i++) {
            wormBodies[i].render.fillStyle = '#4ecdc4';
            wormBodies[i].render.strokeStyle = '#2ca89a';
            wormBodies[i].friction = 0.9;  // Very high friction for grip
            wormBodies[i].frictionStatic = 0.95;  // Very high static friction
            Body.setDensity(wormBodies[i], 0.02); // EXTREMELY heavy tail - 40x heavier than head
            Body.setInertia(wormBodies[i], wormBodies[i].inertia * 10); // High rotational inertia
        }

        // Add worm to world
        Composite.add(world, worm);
        
        // Store references for controls
        const wormSegments = worm.bodies;
        const constraints = worm.constraints;

        // Create ground and walls - make walls thick and partially visible
        const wallThickness = 200;  // Very thick walls
        const wallVisibleAmount = 20;  // How much of the wall to show on screen
        
        const ground = Bodies.rectangle(window.innerWidth / 2, window.innerHeight - 25, window.innerWidth + wallThickness * 2, 50, {
            isStatic: true,
            render: {
                fillStyle: '#2d3436'
            }
        });

        // Left wall - positioned so only the right edge is visible
        const leftWall = Bodies.rectangle(-wallThickness/2 + wallVisibleAmount, window.innerHeight / 2, wallThickness, window.innerHeight * 2, {
            isStatic: true,
            friction: 0.05,  // Some friction but not too much
            restitution: 0.3,  // Some bounce
            render: {
                fillStyle: '#2d3436',
                visible: true
            }
        });

        // Right wall - positioned so only the left edge is visible
        const rightWall = Bodies.rectangle(window.innerWidth + wallThickness/2 - wallVisibleAmount, window.innerHeight / 2, wallThickness, window.innerHeight * 2, {
            isStatic: true,
            friction: 0.05,  // Some friction but not too much
            restitution: 0.3,  // Some bounce
            render: {
                fillStyle: '#2d3436',
                visible: true
            }
        });

        Composite.add(world, [ground, leftWall, rightWall]);

        // Mouse control
        const mouse = Mouse.create(render.canvas);
        const mouseConstraint = MouseConstraint.create(engine, {
            mouse: mouse,
            constraint: {
                stiffness: 0.2,
                render: {
                    visible: false
                }
            }
        });
        Composite.add(world, mouseConstraint);
        render.mouse = mouse;

        // Input handling
        const keys = {};
        let isCompressing = false;

        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            
            // Start compression when spacebar is pressed
            if (e.key === ' ' && !isCompressing) {
                isCompressing = true;
                //console.log('Compression started');
                // Increase stiffness for compression
                constraints.forEach(c => {
                    c.stiffness = compressStiffness;
                });
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
            
            // Release compression when spacebar is released
            if (e.key === ' ' && isCompressing) {
                isCompressing = false;
                // console.log('Compression stopped');
                // Increase stiffness for compression
                // Reset compression constraints
                constraints.forEach(c => {
                    c.stiffness = baseStiffness;
                });
                e.preventDefault();
            }
        });

        // Update function
        Events.on(engine, 'beforeUpdate', () => {
            // Apply forces only to head segments
            const numSegmentsToMove = Math.min(2, wormRows); // Only move top 2 segments
            const headSegments = wormSegments.slice(-numSegmentsToMove);
            const force = 0.003; // Much reduced force for rage game difficulty
            
            // Apply forces based on input - this will feel sluggish due to heavy tail
            if (keys['ArrowLeft']) {
                headSegments.forEach((segment, i) => {
                    // Apply torque as well for better turning
                    const segmentForce = force * (1 - i * 0.3);
                    Body.applyForce(segment, segment.position, { x: -segmentForce, y: 0 });
                    Body.setAngularVelocity(segment, segment.angularVelocity - 0.01);
                });
            }
            
            if (keys['ArrowRight']) {
                headSegments.forEach((segment, i) => {
                    // Apply torque as well for better turning
                    const segmentForce = force * (1 - i * 0.3);
                    Body.applyForce(segment, segment.position, { x: segmentForce, y: 0 });
                    Body.setAngularVelocity(segment, segment.angularVelocity + 0.01);
                });
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            render.canvas.width = window.innerWidth;
            render.canvas.height = window.innerHeight;
        });

        // Run the engine
        Runner.run(runner, engine);
        Render.run(render);

        // Create dat.GUI
        const gui = new dat.GUI();
        
        // Movement folder
        const movementFolder = gui.addFolder('Movement');
        movementFolder.add(physicsParams, 'movementForce', 0.0001, 0.02).step(0.0001);
        movementFolder.add(physicsParams, 'upwardForce', 0.0001, 0.02).step(0.0001);
        movementFolder.add(physicsParams, 'numSegmentsToMove', 1, 5).step(1);
        movementFolder.add(physicsParams, 'torqueAmount', 0, 0.05).step(0.001);
        movementFolder.open();
        
        // Tail folder
        const tailFolder = gui.addFolder('Tail Physics');
        tailFolder.add(physicsParams, 'tailDensity', 0.001, 0.1).step(0.001).onChange(value => {
            // Update tail density
            const tailSegs = Math.min(physicsParams.tailSegments, wormRows);
            for (let i = 0; i < tailSegs * wormColumns; i++) {
                Body.setDensity(wormSegments[i], value);
            }
        });
        tailFolder.add(physicsParams, 'tailInertiaMultiplier', 1, 20).step(0.5).onChange(value => {
            // Update tail inertia
            const tailSegs = Math.min(physicsParams.tailSegments, wormRows);
            for (let i = 0; i < tailSegs * wormColumns; i++) {
                const baseMass = wormSegments[i].mass;
                const baseInertia = baseMass * particleRadius * particleRadius / 2;
                Body.setInertia(wormSegments[i], baseInertia * value);
            }
        });
        tailFolder.add(physicsParams, 'tailFriction', 0, 1).step(0.01).onChange(value => {
            const tailSegs = Math.min(physicsParams.tailSegments, wormRows);
            for (let i = 0; i < tailSegs * wormColumns; i++) {
                wormSegments[i].friction = value;
            }
        });
        tailFolder.add(physicsParams, 'tailStaticFriction', 0, 1).step(0.01).onChange(value => {
            const tailSegs = Math.min(physicsParams.tailSegments, wormRows);
            for (let i = 0; i < tailSegs * wormColumns; i++) {
                wormSegments[i].frictionStatic = value;
            }
        });
        tailFolder.add(physicsParams, 'tailSegments', 1, 5).step(1);
        
        // Head folder
        const headFolder = gui.addFolder('Head Physics');
        headFolder.add(physicsParams, 'headDensity', 0.0001, 0.01).step(0.0001).onChange(value => {
            // Update head density
            for (let i = numBodies - wormColumns; i < numBodies; i++) {
                Body.setDensity(wormSegments[i], value);
            }
        });
        
        // Body folder
        const bodyFolder = gui.addFolder('Body Physics');
        bodyFolder.add(physicsParams, 'bodyDensity', 0.0001, 0.01).step(0.0001).onChange(value => {
            // Update body density for middle segments
            const tailSegs = Math.min(physicsParams.tailSegments, wormRows);
            for (let i = tailSegs * wormColumns; i < numBodies - wormColumns; i++) {
                Body.setDensity(wormSegments[i], value);
            }
        });
        bodyFolder.add(physicsParams, 'bodyFriction', 0, 1).step(0.01).onChange(value => {
            const tailSegs = Math.min(physicsParams.tailSegments, wormRows);
            for (let i = tailSegs * wormColumns; i < numBodies - wormColumns; i++) {
                wormSegments[i].friction = value;
            }
        });
        bodyFolder.add(physicsParams, 'bodyAirFriction', 0, 0.1).step(0.001).onChange(value => {
            wormSegments.forEach(segment => {
                segment.frictionAir = value;
            });
        });
        
        // Constraints folder
        const constraintsFolder = gui.addFolder('Constraints');
        constraintsFolder.add(physicsParams, 'constraintStiffness', 0.01, 1).step(0.01).onChange(value => {
            if (!isCompressing) {
                constraints.forEach(c => {
                    c.stiffness = value;
                });
            }
        });
        constraintsFolder.add(physicsParams, 'constraintDamping', 0, 0.5).step(0.01).onChange(value => {
            constraints.forEach(c => {
                c.damping = value;
            });
        });
        constraintsFolder.add(physicsParams, 'compressStiffness', 0.1, 1).step(0.01);
        
        // Mass gradient
        gui.add(physicsParams, 'massGradientMultiplier', 0, 2).step(0.1).onChange(value => {
            // Reapply mass gradient
            for (let i = 0; i < numBodies; i++) {
                const segmentRow = Math.floor(i / wormColumns);
                const massMultiplier = 1 + (segmentRow * value);
                const baseDensity = i < physicsParams.tailSegments * wormColumns ? physicsParams.tailDensity :
                                  i >= numBodies - wormColumns ? physicsParams.headDensity : physicsParams.bodyDensity;
                Body.setDensity(wormSegments[i], baseDensity * massMultiplier);
            }
        });
        
        // Export settings button
        const exportButton = {
            exportSettings: function() {
                console.log('// Copy these values back into physicsParams:');
                console.log('const physicsParams = ' + JSON.stringify(physicsParams, null, 4) + ';');
                alert('Settings exported to console! Press F12 to open developer console and copy the values.');
            }
        };
        gui.add(exportButton, 'exportSettings').name('Export Settings to Console');

        // Update compression to use GUI value
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            
            if (e.key === ' ' && !isCompressing) {
                isCompressing = true;
                constraints.forEach(c => {
                    c.stiffness = physicsParams.compressStiffness;
                });
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
            
            if (e.key === ' ' && isCompressing) {
                isCompressing = false;
                constraints.forEach(c => {
                    c.stiffness = physicsParams.constraintStiffness;
                });
                e.preventDefault();
            }
        });

        // Update the movement function to use GUI values
        Events.off(engine, 'beforeUpdate');
        Events.on(engine, 'beforeUpdate', () => {
            // Apply velocity damping to reduce drift
            wormSegments.forEach(segment => {
                if (Math.abs(segment.velocity.x) < 0.1 && Math.abs(segment.velocity.y) < 0.1) {
                    Body.setVelocity(segment, { x: segment.velocity.x * 0.9, y: segment.velocity.y * 0.9 });
                }
                if (Math.abs(segment.angularVelocity) < 0.01) {
                    Body.setAngularVelocity(segment, segment.angularVelocity * 0.9);
                }
            });
            
            const numSegmentsToMove = Math.min(physicsParams.numSegmentsToMove, wormRows);
            const headSegments = wormSegments.slice(-numSegmentsToMove);
            const force = physicsParams.movementForce;
            
            if (keys['ArrowLeft']) {
                headSegments.forEach((segment, i) => {
                    const segmentForce = force * (1 - i * 0.3);
                    Body.applyForce(segment, segment.position, { x: -segmentForce, y: 0 });
                    Body.setAngularVelocity(segment, segment.angularVelocity - physicsParams.torqueAmount);
                });
            }
            
            if (keys['ArrowRight']) {
                headSegments.forEach((segment, i) => {
                    const segmentForce = force * (1 - i * 0.3);
                    Body.applyForce(segment, segment.position, { x: segmentForce, y: 0 });
                    Body.setAngularVelocity(segment, segment.angularVelocity + physicsParams.torqueAmount);
                });
            }
            
            if (keys['ArrowUp']) {
                headSegments.forEach((segment, i) => {
                    const segmentForce = physicsParams.upwardForce * (1 - i * 0.2);
                    Body.applyForce(segment, segment.position, { x: 0, y: -segmentForce });
                });
            }
        });
    </script>
</body>
</html>
